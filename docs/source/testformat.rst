.. _test_format_spec:

################
Test Format Spec
################

Vocabulary
----------


.. _compliance_test:

The compliance test
^^^^^^^^^^^^^^^^^^^
The compliance test is a nonfunctional testing technique which is done to validate whether the system 
developed meets the prescribed standard or not. In this particular case the golden reference is 
the RISC-V ISA standard.

For purpose of this document we understand that the compliance test is a single test which 
represents the minimum test code that can be compiled and run. It is written in assembler code 
and its product is a :ref:`test signature <test_signature>`. A compliance test may consist of 
several :ref:`test cases <test_case>`.

.. _compliance_test_pool:

The RISC-V compliance test pool
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The RISC-V compliance test pool consists of all approved :ref:`compliance tests <compliance_test>` that can be assembled by the test framework, forming the :ref:`compliance test suite <compliance_test_suite>`. The RISC-V compliance test pool must be test target independent (so, should correctly run on any compliant target). Note that this nonfunctional testing is not a substitute for verification or device test.

.. _compliance_test_suite:

The RISC-V compliance test suite
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The RISC-V compliance test suite is a group of tests selected from the :ref:`compliance test pool <compliance_test_pool>` to test compliance for the specific RISC-V configuration. Test results are obtained in the form of a :ref:`test suite signature <test_suite_signature>`. Selection of tests is performed based on the target's asserted configuration, and the spec,  Execution Environment or platform requirements. Compliant processor or processor models shall exhibit the same test suite signature as the golden reference test suite signature for the specific configuration being tested.


.. _test_case:

The test case
^^^^^^^^^^^^^
A *test case* is part of the compliance test that tests just one feature of the specification.


.. note:: a single test can contain multiple test cases, each of which can have its own test inclusion condition (as defined by the cond_str parameter of the RVTEST_CASE macro.

.. image:: testpool.jpg
    :align: center
    :alt: testStruct

.. _test_case_signature:

The test case signature
^^^^^^^^^^^^^^^^^^^^^^^
The *test case signature* is represented by single or multiple values. Values are written to memory at the address starting at the address specified by the RVMODEL_DATA_BEGIN and ending at RVMODEL_DATA_END. Signatures can be generated most easily using the RVTEST_SIGUPD macro.

.. _test_signature:

The test signature
^^^^^^^^^^^^^^^^^^
The :ref:`test signature <test_signature>` is a characteristic value which is generated by the compliance test run. The :ref:`test signature <test_signature>` may consist of several :ref:`test case signature <test_case_signature>`, prefixed with a separate line containing the name of the test and a unique value indicating its version (e.g. git checkin hash). The test target is responsible for extracting values from memory and properly formatting them, using metadata provided to it by the framework using the RVMODEL_DATA_BEGIN and RVMODEL_DATA_END macros. Test case signature values are written one per line, starting with the most-significant byte on the left-hand side with the format <hex_value> where the length of value will be 32 bits (so 8 characters), regardless of the actual value length computed by the test.

.. _test_suite_signature:

The test suite signature
^^^^^^^^^^^^^^^^^^^^^^^^
The *test suite signature* is defined as a set of :ref:`test signature <test_signature>` valid for given :ref:`computed test suite <compliance_test_suite>`. It represents the test signature of the particular RISC-V configuration selected for the compliance test.

.. _target_shell:

The target shell
^^^^^^^^^^^^^^^^
The :ref:`target shell<target_shell>` is a vendor-supplied software and hardware environment around the :ref:`test target <test_target>` that enables it to communicate with the framework, including assembling and linking tests, loading tests into memory, executing tests, and extracting the signature. The input to the :ref:`target shell<target_shell>` is a .S :ref:`compliance test <compliance_test>` file, and the output is a :ref:`test signature <test_signature>`.

.. _test_target:

The test target
^^^^^^^^^^^^^^^
The :ref:`test target <test_target>` can include a RISC-V Instruction Set Simulator (ISS), a RISC-V emulator, a RISC-V RTL model running on an HDL simulator, a RISC-V FPGA implementation or a physical chip or ohter model type. Each of the target types offers specific features and represents specific interface challenges. It is a role of the  :ref:`target shell <target_shell>` to handle different targets while using the same :ref:`compliance test pool <compliance_test_pool>` as a test source.

.. The RISC-V processor (device) configuration
.. ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. The RISC-V ISA specification allows many optional instructions, registers, and other features. Production directed targets typically have a fixed subset of available options. A simulator, on the other hand, may implement all known options which may be constrained to mimic the behavior of the RISC-V processor with the particular configuration.  It is a role of the Compliance Test Framework to build and use the :ref:`compliance test suite <compliance_test_suite>` suitable for the selected RISC-V configuration.

.. _compliance_test_framework:

The compliance test framework
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The :ref:`compliance test framework <compliance_test_framework>` selects and configures the :ref:`compliance test suite <compliance_test_suite>` from the :ref:`compliance test pool <compliance_test_pool>` for the selected :ref:`test target <test_target>` based on both the specific architectural choices made by an implementation and those required by the Execution Environment It causes the :ref:`target shell <target_shell>` to build, execute, and report a signature. The :ref:`compliance test framework <compliance_test_framework>` then compares reported signatures, inserts test part names and version numbers and summarizes differences (or lack of them) into a RISC-V compliance report. The primary role of the well-defined :ref:`compliance test pool <compliance_test_pool>` structure is to provide the tests in a form suitable for the Compliance Test Framework selection engine.


Compliance test pool 
--------------------

.. _test_pool_structure:

Test pool structure
^^^^^^^^^^^^^^^^^^^

The structure of :ref:`compliance test <compliance_test>` in the :ref:`compliance test pool <compliance_test_pool>` shall be based on defined RISC-V extensions and privileged mode selection. This will provide a good overview of which parts of the ISA specification are already covered in the :ref:`compliance test suite <compliance_test_suite>`, and which tests are suitable for certain configurations. The compliance test pool has this structure:

.. code-block:: bash

  compliance-tests-suite (root)
  -- <architecture>_<mode>/<feature(s)>, where

  <architecture> is [ RV32I | RV64I | RV32E ]

  <mode> is [ M | MU | MS | MSU ], where
     M   Machine      mode tests - tests execute in M-mode only 
     MU  Machine/User mode tests - tests execute in both M- & U-modes (S-mode may exist)
     MS  Machine/Supv mode tests - tests execute in both M- & S-modes (not U-mode)
     MSU All          mode tests - tests execute in all of M-, S-, & U-Modes

  <feature(s)> are the lettered extension [A | B | C | M ...] or subextension [Zifencei | Zam | ...] 
  when the tests involve extensions, or more general names when tests cut across extension 
  definitionss (e.g. Priv, Interrupt, Vm). The feature string consists of an initial capital 
  letter, followed by any further letters in lower case.

.. note:: this structure is for organizational purposes, not functional purposes, although full test names will take advantage of it.

Tests that will be executed in different modes, even if the results are identical, should be replicated in each mode directory, e.g. RV32I_M/, RV32I_MS/, and RV32I_MU/. These tests  are typically those involving trapping behavior, e.g load, store, and privilged ops.

Test naming
^^^^^^^^^^^

The naming convention of a single test:

*<test objective>-<test number>.S*

  * **test objective** - an aspect that the test is focused on. A test objective may be an instruction for ISA tests (ADD, SUB, ...), or a characteristic covering multiple instructions, e.g. exception event (misaligned fetch, misalign load/store) and others.
  
  * **test number** - number of the test. It is expected that multiple tests may be specified for oneÂ test objective. We recommend to break down complex tests into a set of small tests. A simple rule of thumb is one simple test objective = one simple test. The code becomes more readable and the test of the objective can be improved just by adding :ref:`test case <test_case>`. The typical example are instruction tests for the F extension. 
  
  *  A test name shall not include an ISA category as part of its name (i.e. the directory, subdirectory names). Experience has shown that including ISA category in the test name leads to very long test names. Instead, we have introduced the :ref:`Test pool structure<test_pool_structure>` where the full name is composed of the test path in the :ref:`Test pool structure<test_pool_structure>` and the simple test name. Since full names can be reconstructed easily it is not necessary to include the path in test names.

The test structure of a compliance test
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
All tests shall use a signature approach. Each test shall be written in the same style, with 
defined mandatory items.The test structure of a compliance test shall have the following sections 
in the order as follows:

  * Header + license (including a specification link, a brief test description and RVTEST_ISA macro))
  * Includes of header files (see Common Header Files section)
  * Test Virtual Machine (TVM) specification
  * Test code between âRVTEST_CODE_BEGINâ and âRVTEST_CODE_ENDâ
  * Input data section, marked with "RVMODEL_DATA_SECTION"
  * Output data section between âRVMODEL_DATA_BEGINâ and âRVMODEL_DATA_ENDâ.

.. note:: there is no a requirement that the code or scratch data sections must be contiguous in memory, or that they be located before or after data or code sections (configured by embedded directives recognized by the linker)

.. _available_macros:

Available Macros
^^^^^^^^^^^^^^^^
There are both pre-defined and model-specific macros which shall be used in every test to 
guarantee their portability. In addition, there are both pre-defined and model specific macros 
that are not required, but may be used in tests.

  * **Required, Pre-defined Macros** 
  
    - ``RVTEST_ISA(isa_str)`` : defines the Test Virtual Machine (TVM, the ISA being tested) 
  
      -  Empty macro to specify the isa required for compilation of the test. 
      -  This is mandated to be present at the start of the test. 
  
    - ``RVTEST_CODE_BEGIN`` : start of code (test) section 
 
      - this macro also includes the ``RVMODEL_BOOT`` macro at the begining.
      - Macro to indicate test code start address and where test startup routine is inserted. 
      - No part of the code section should precede this macro 
  
    - ``RVTEST_CODE_END`` : end of code (test) section 
  
      - Macro to indicate test code end. 
      - No part of the code section should follow after this macro. 
  
    - ``RVTEST_CASE(CaseName, CondStr)`` : execute this case only if condition in cond_str are met 
  
      - CaseName is arbitrary string  
      - CondStr is evaluated to determine if the test-case is enabled and sets name variable 
      - CondStr can also define compile time macros required for the test-case to be correctly
        executed. 
      - the test-case must be delimited with an #ifdef CaseName/#endif pair 
  
  ..    - the format of CondStr can be found in https://riscof.readthedocs.io/en/latest/cond_spec.html#cond-spec
  
  * **Required, Model-defined Macros** 
  
    - ``RVMODEL_DATA_BEGIN`` : start of output data (signature) section 
    - ``RVMODEL_DATA_END`` : end of output data (signature) section 
    - ``RVMODEL_DATA_SECTION`` : model defined data area 
  
        - contains static input data and intermediate scratch area for the test (e.g. stack) 
  
    - ``RVMODEL_HALT`` :  defines model halt mechanism, which starts signature saving
  
  * **Optional, Pre-defined Macros**
  
    - ``RVTEST_SIGBASE(BaseReg,Val)``: defines the base register used to update signature values 
  
      - Register BaseReg is loaded with value Val 
      - hidden_offset is initialized to zero 
  
    - ``RVTEST_SIGUPD(BaseReg, SigReg [,Value])`` : stores sig value, with optional value assertion 
  
      - Register Val is stored in mem(reg_Base+hidden_offset) 
      - hidden_offset is post incremented  so repeated uses store signature values sequentially 
  
    - ``RVTEST_BASEUPD(BaseReg[oldBase[,newOff]])`` : [moves &] updates BaseReg past stored signature 
  
      - Register BaseReg is loaded with the oldReg+newOff+hidden_offset 
      - BaseReg is used if oldBase isn't specified; 0 is used if newOff isn't specified 
      - hidden_offset is re-initialized to 0 afterwards
  
  * **Optional, Model-defined Macros**
  
    - ``RVMODEL_BOOT`` : This macro is placed within the ``RVTEST_CODE_BEGIN`` macro (at the very start) and may include model specific boot-routines, emulation code or trap stubs.

    - ``RVMODEL_IO_INIT`` : initializes IO for debug output 
  
      - this must be invoked if any of the other RV_MODEL_IO_* macros are used 
  
    - ``RVMODEL_IO_CHECK`` : checks IO for debug output 
  
      - <needs description of how this is used > 
  
    - ``RVMODEL_IO_ASSERT_GPR_EQ(ScrReg, Reg, Value)`` : debug assertion that GPR should have value 
  
      - outputs a debug message if Reg!=Value 
      - ScrReg is a scratch register used by the output routine; its final value cannot be guaranteed 
  
    - ``RVMODEL_IO_WRITE_STR(ScrReg, String)`` :output debug string, using a scratch register 
  
      - outputs the message String
      - ScrReg is a scratch register used by the output routine; its final value cannot be guaranteed 


Common test format rules
^^^^^^^^^^^^^^^^^^^^^^^^

There are the following common rules that shall be applied to each :ref:`compliance test <compliance_test>`:

  1. Always use ``//`` as commentary. ``#`` should be used only for includes and defines.
  2. A test shall be divided into logical blocks (:ref:`test case <test_case>`) according to the test goals. Test cases are enclosed in an ``#ifdef <__CaseName__>, #endif`` pair and begin with the ``RVTEST_CASE(CaseName,CondStr)`` macro that specifies the test case name, and a string that defines the conditions under which that :ref:`test case <test_case>` can be selected for assembly and execution. Those conditions will be collected and used to generate the database which in turn is used to select tests for inclusion in the test suite for this target.
  3. Tests should use the ``RVTEST_SIGBASE(BaseReg,Val)`` macro to define the GPR used as a pointer to the output signature area, and its initial value. It can be used multiple times within a test to reassign the output area or change the base register. This value will be used by the invocations of the ``RVTEST_SIGUPD`` macro.
  4. Tests should use the ``RVTEST_SIGUPD(BaseReg, SigReg, ScratchReg, Value)`` macro to store signature values using (only) the base register defined in the most recently encountered ``RVTEST_SIGBASE(BaseReg,Val)`` macro. Repeated uses will automatically have an increasing offset that is managed by the macro. 

    i. Uses of ``RVTEST_SIGUPD`` shall always be preceded sometime in the test case by ``RVTEST_SIGBASE``. 
    ii. The SIGUPD macro may optionally invoke a test assertion macro (e.g. ``RVMODEL_IO_ASSERT_GPR_EQ``) with an assertion value for debugging, determined by the presence of ScratchReg and Value parameters. 
    iii. Tests that use SIGUPD inside a loop or in any section of code that will be repeated (e.g. traps) must use the BASEUPD macro between each loop iteration or repeated code to ensure static values of the base and offset don't overwrite older values.

  5. When macros are needed for debug purposes, only macros from compliance_model.h shall be used. 

    .. note:: that using this feature shall not affect the signature results of the test run.

  6. Test shall not include other tests (e.g. #include â../add.Sâ) to prevent non-complete tests, compilation issues, and problems with code maintenance.

  7. Tests and test cases shall be skipped if not required for a specific model test configuration based on test conditions defined in the ``RVTEST_CASE`` macro. Tests that are selected may be further configured using variables (e.g. XLEN) which are passed into the tests and used to compile them. In either case, those conditions and variables are derived from the YAML specification of the device and execution environment that are passed into the framework. The :ref:`compliance test framework <compliance_test_framework>` build and runs a :ref:`compliance test suite <compliance_test_suite>` from the :ref:`compliance test pool <compliance_test_pool>` to determine which tests and test cases to run.

  8. Tests shall not depend on tool specific features. For example, tests shall avoid usage of internal GCC macros (e..g. ``__riscv_xlen__``), specific syntax (char 'a' instead of 'a) or simulator features (e.g. tohost) etc.

  9. Each test shall be ended by the (target specific) ``RVMODEL_HALT`` macro. Depending on branches in the test, there may be more than one instance of this in a test all of which to be present within the ``RVTEST_CODE_BEGIN`` and ``RVTEST_CODE_END`` pair.
  10. Macros defined outside of a test shall only be defined in specific predefined header files (see :ref:`Common Header Files <common_header_files>` below), and once they are in use, they may be modified only if the function of all affected tests remains unchanged.

.. _common_header_files:

Common Header Files
^^^^^^^^^^^^^^^^^^^

Each test shall include only the following header files:

  * *compliance_model.h* â defines target-specific macros, both required and optional:  (e.g. ``RVMODEL_xxx``)
  * *compliance_test.h* â  defines pre-defined test macros both required and optional:  (e.g. ``RVTEST_xxx``)

Adding new header files is forbidden. It may lead to macro redefinition and compilation issues.
Macros maybe defined and used inside a test, as they will not be defined outside that specific test.
Assertions will generate code that reports assertion failures (and optionally successes?) only if enabled by the framework.
In addition, the framework may collect the assertion values and save them as a signature output file if enabled by the framework.

.. Framework Requirements
.. ^^^^^^^^^^^^^^^^^^^^^^
.. 
.. The framework will import files that describe 
.. 
.. - the implemented, target-specific configuration parameters in YAML format
.. 
.. - the required, platform-specific  configuration parameters in YAML format
.. 
.. The framework will generate intermediate files, including a Test Database YAML file that selects tests from the test pool to generate a test suite for the target.
.. 
.. The framework will also invoke the :ref:`target shell <target_shell>` as appropriate to cause tests to be built, loaded, executed, and results reported.
.. 
.. The YAML files define both the values of those conditions and values that can be used by the framework to configure tests (e.g. format of WARL CSR fields). 
.. Tests should not have #if, #ifdef, etc. for conditional assembly except those that surround RVMODEL_CASE macros
.. Instead, each of those should be a separate :ref:`test case <test_case>` whose conditions are defined in
..  the common reference document entry for that test and test case number.

RVTEST_CASE Condition Formating
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This section describes the format for the conditions `CondStr` to be followed while writing the ``RVTEST_CASE`` macro. 
Each of the statements within this macro ends with a ';' .

The macro follows the convention mentioned :ref:`here <available_macros>`. This section describes
the syntax to be followed by the CondStr of the ``RVTEST_CASE`` macro.


.. note::
  A keylist is a string of '>' separated words(keys) which is used to navigate the supplied specs. The schema may be used to specify them. Only valid keys and their combinations are allowed(as present in the scema).

There are two types of valid statements allowed.

1. ``check`` statements 

    These statements get translated into the condtions which need to be true for the part to be enabled.
    The condition can be structured in one of the following allowed ways.
    
    * keylist:=value

        The *keylist* specifies the path to the field in the ISA YAML dictionary whose value needs to be checked. 
        The *value* is the value against which the entry in the input yaml is checked.
        The *value* can be a regular expression as well, in which case it should be specified as *regex("expression")*

        Example: 

        .. code-block:: none

           check ISA:=regex(.*I.*Zicsr.*);  # checks if ISA node supports I and Zicsr extensions.

           check hw_data_misaligned_support:=True; # checks if the misaligned support is available.
    
    * keylist=key

        The *keylist* specifies the path to the field whose keys needs to be checked. 
        The *key* is the key whose presence needs to be checked in the field specified by the keylist.

        Example:

        .. code-block:: none

           check mtvec>rv32>base>type=warl; # checks if mtvec is a warl field

    * function_call=Rval
      
        The *function_call* specifies the function to be called along with the arguments to be specified to the function. The node from the yaml which has to be passed to the function can be specified using the *keylist*. 
        *Rval* is the value against which the return value of the function is checked. The list of different functions,arguments and their return values is listed below.
        
        **Function Signatures**

            * writable(bit_position,keylist_for_field) -> bool
              
                Checks whether the bit at *bit_position* for a particular *csr_field_name* is writable. This function is typically used for *WARL* nodes.
            * islegal(value,dependency_values_list,keylist_for_field) -> bool
              
                This function is valid only for *WARL* fields in the csrs. Checks whether the *value* is a legal value when the values of the fields listed as dependency for the field in question on is equal to the *dependency_values_list*.

        Example:

        .. code-block:: none
            
            check writable(12,misa>rv32>extensions)=True; # checks if 12th bit in MISA is writable.

2. ``def`` statements
    
    .. code-block:: none
        
        def macro(s)(=value/keylist/function);
    
    These statements specify which macros to be defined for the part to run and their values(optional).
    * The macro specifies the name of the macro.
    * Multiple macros can be specified using a comma inbetween them.
    * A keylist specifying the path of the field whose value has to be passed as the value of the macro can also be given.
    * A function along with the arguments can also be specified. At runtime the function is called using the specified arguments and its return values are assigned to the macro(s) specified. The list of functions supported are as follows.

        **Function Signatures**
        
            * getlegal(dependency_values_list,num_vals,key_list_for_field) -> list(int)
              
                This function is valid only for *WARL* fields in the csrs. It returns a list of legal values for the specified field when the values of the fields listed as dependency for the field in question on is equal to the *dependency_values_list*. The length of the list returned is equal to *num_vals*. Each entry in the list is assigned to the corresponding macro listed on the left hand side of the *=* sign.

            * getillegal(dependency_values_list,num_vals,key_list_for_field) -> list(int)
              
                This function is valid only for *WARL* fields in the csrs. It returns a list of illegal values for the specified field when the values of the fields listed as dependency for the field in question on is equal to the *dependency_values_list*. The length of the list returned is equal to *num_vals*. Each entry in the list is assigned to the corresponding macro listed on the left hand side of the *=* sign.

    Example:

    .. code-block:: none

        def TEST_CASE_1=True; # enables TEST_CASE_1 macro during compilation phase.

        def rvtest_mtrap_routine=True; #enabled trap routines during compilation phase.

        # Assigns a legal value(for the base field in mtvec) to LEGAL_2_1
        def LEGAL_2_1 = getlegal([0],1,mtvec>rv32>base);             
        
        # Assigns an illegal value(for the base field in mtvec) each to ILLEGAL_2_1 and ILLEGAL_2_2
        def ILLEGAL_2_1,ILLEGAL_2_2 = getillegal([0],2,mtvec>rv32>base);  
